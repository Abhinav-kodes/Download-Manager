#include "downloadwindow.h" // Includes the header file for this class (DownloadWindow). This declares the class structure.
#include "ui_downloadwindow.h" // Includes the header file generated by Qt's UI compiler (uic) from the .ui file. It defines the `Ui::DownloadWindow` class which sets up the graphical elements.
#include "downloader.h" // Includes the header file for the Downloader class, which handles the actual file downloading logic.
#include <QMessageBox> // Includes the Qt class for displaying standard message boxes (like warnings or information).
#include <QFileDialog> // Includes the Qt class for showing standard file dialogs (like "Save As...").
#include <QThread> // Includes the Qt class for managing threads.
#include <QTimer> // Includes the Qt class for creating timers that fire signals at regular intervals.
#include <iostream> // Includes the standard C++ library for input/output streams (used here for debug messages with std::cout/cerr).
#include <QLocale> // Include for formatting size

// Constructor for the DownloadWindow class.
DownloadWindow::DownloadWindow(QWidget *parent) // Takes an optional parent widget, standard for Qt widgets.
    : QDialog(parent) // Initializes the base class (QDialog), making this a dialog window.
    , ui(new Ui::DownloadWindow) // Creates an instance of the UI class generated from the .ui file.
    , downloadThread(nullptr) // Initializes the pointer to the download thread to null.
    , downloader(nullptr) // Initializes the pointer to the Downloader object to null.
    , isDownloading(false) // Initializes the flag indicating if a download is active to false.
{
    ui->setupUi(this); // Sets up the user interface defined in the .ui file onto this dialog window.
    setWindowTitle("Download Manager"); // Sets the title displayed in the window's title bar.

    // Connect buttons signals to slots (methods) in this class.
    // When downloadButton is clicked, call the onDownloadClicked method.
    connect(ui->downloadButton, &QPushButton::clicked, this, &DownloadWindow::onDownloadClicked);
    // When pauseResumeButton is clicked, call the onPauseResumeClicked method.
    connect(ui->pauseResumeButton, &QPushButton::clicked, this, &DownloadWindow::onPauseResumeClicked);
    
    // Initially disable the pause/resume button because no download is active.
    ui->pauseResumeButton->setEnabled(false);
    // Set the initial text of the pause/resume button.
    ui->pauseResumeButton->setText("Pause");

    // Create a timer to update the UI regularly.
    QTimer *progressTimer = new QTimer(this); // Creates a QTimer object, with this window as its parent (for memory management).
    // Connect the timer's timeout signal to the updateUI slot.
    connect(progressTimer, &QTimer::timeout, this, &DownloadWindow::updateUI);
    // Start the timer to emit the timeout signal every 100 milliseconds.
    progressTimer->start(100);
}

// Destructor for the DownloadWindow class.
DownloadWindow::~DownloadWindow()
{
    // Clean up the download thread if it exists and is running.
    if (downloadThread && downloadThread->isRunning()) {
        if (downloader) {
            QMetaObject::invokeMethod(downloader, "pauseDownload", Qt::BlockingQueuedConnection); // Blocking call to ensure pause happens.
        }
        downloadThread->quit(); // Politely asks the thread's event loop to exit.
        if (!downloadThread->wait(3000)) { // Waits up to 3000 milliseconds (3 seconds) for the thread to finish cleanly.
            // If the thread doesn't finish within the timeout...
            std::cerr << "Warning: Download thread did not finish gracefully. Terminating." << std::endl; // Print a warning.
            downloadThread->terminate(); // Forcefully terminates the thread (use with caution, can cause resource leaks).
            downloadThread->wait(); // Wait again after termination to ensure OS cleans up thread resources.
        }
    }
    delete ui; // Deletes the UI object created in the constructor, standard Qt cleanup.
}

// Slot to update the UI based on the downloader's state. Called by the QTimer.
void DownloadWindow::updateUI()
{
    // Do nothing if no download is active or the downloader object doesn't exist.
    if (!isDownloading || !downloader) return;

    // Update the pause/resume button based on whether the downloader is currently paused.
    if (downloader->isPaused()) {
        ui->pauseResumeButton->setText("Resume"); // Set text to "Resume" if paused.
        ui->pauseResumeButton->setEnabled(true); // Ensure button is enabled.
    } else {
        ui->pauseResumeButton->setText("Pause"); // Set text to "Pause" if running.
        ui->pauseResumeButton->setEnabled(true); // Ensure button is enabled.
    }

    // Process any pending events in the Qt event loop to keep the UI responsive.
    // Note: Frequent calls can sometimes impact performance; the timer helps regulate this.
    QCoreApplication::processEvents();
}

// Helper function to centralize updating the enabled/disabled state and text of buttons.
void DownloadWindow::updateButtonStates() {
    if (isDownloading) { // If a download is currently active...
        ui->downloadButton->setEnabled(false); // Disable the main download button.
        // Enable the pause/resume button only if the downloader object actually exists.
        ui->pauseResumeButton->setEnabled(downloader != nullptr);

        // Check the actual paused state of the downloader to set the button text correctly.
        if (downloader && downloader->isPaused()) {
            ui->pauseResumeButton->setText("Resume");
        } else {
            ui->pauseResumeButton->setText("Pause");
        }
    } else { // If no download is active...
        ui->downloadButton->setEnabled(true); // Enable the main download button.
        ui->pauseResumeButton->setEnabled(false); // Disable the pause/resume button.
        ui->pauseResumeButton->setText("Pause"); // Reset the text to "Pause".
    }
}

// Slot called when the "Download" button is clicked.
void DownloadWindow::onDownloadClicked() {
    // Get the URL text entered by the user.
    QString url = ui->urlLineEdit->text();

    // Check if the URL is empty.
    if (url.isEmpty()) {
        // Show a warning message if the URL is empty.
        QMessageBox::warning(this, "Error", "Please enter a URL.");
        return; // Stop processing.
    }

    // Ensure the URL starts with "http://" or "https://". If not, prepend "https://".
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
        url = "https://" + url;
    }

    // Try to extract a default filename from the last part of the URL path.
    QString defaultName = url.split("/").last();
    // If the extracted name is empty or doesn't look like a filename (no dot)...
    if (defaultName.isEmpty() || !defaultName.contains(".")) {
        // Try to guess a file extension based on common types found in the URL.
        if (url.contains(".pdf", Qt::CaseInsensitive)) {
            defaultName = "download.pdf";
        } else if (url.contains(".jpg", Qt::CaseInsensitive) ||
                  url.contains(".jpeg", Qt::CaseInsensitive)) {
            defaultName = "download.jpg";
        } else if (url.contains(".png", Qt::CaseInsensitive)) {
            defaultName = "download.png";
        } else {
            // Default to ".html" if no other extension is guessed.
            defaultName = "download.html";
        }
    }

    // Create a file filter string for the "Save As" dialog based on the guessed extension.
    QString filter = "All Files (*.*)"; // Default filter.
    if (defaultName.contains(".")) { // If the default name has an extension...
        QString ext = defaultName.split(".").last(); // Extract the extension.
        if (!ext.isEmpty()) {
            // Create a specific filter like "PDF Files (*.pdf);;All Files (*.*)".
            filter = QString("%1 Files (*.%2);;All Files (*.*)").arg(ext.toUpper()).arg(ext);
        }
    }

    // Show the "Save As" dialog to let the user choose the save location and filename.
    QString output = QFileDialog::getSaveFileName(this, "Save File",
                                                 defaultName, // Suggest the default filename.
                                                 filter); // Use the generated filter.

    // If the user clicked "Cancel" in the dialog, the output path will be empty.
    if (output.isEmpty()) return; // Stop processing.

    // Reset the progress bar to 0 before starting a new download.
    ui->progressBar->setValue(0);

    // Reset the progress bar and size label before starting a new download.
    ui->progressBar->setValue(0);
    ui->sizeLabel->setText("Size: Determining..."); // Initial text
    ui->speedLabel->setText("Speed: 0 B/s"); // Reset speed label

    // --- Cleanup existing thread and downloader first ---
    // Check if a download thread already exists from a previous download.
    if (downloadThread) {
        if (downloadThread->isRunning()) { // Check if the previous thread is still running.
            std::cout << "Cleaning up previous download thread..." << std::endl;

            // Pause the download if it's currently running.
            if (downloader) {
                QMetaObject::invokeMethod(downloader, "pauseDownload", Qt::BlockingQueuedConnection);
            }
            downloadThread->quit(); // Ask the previous thread to stop its event loop.
            if (!downloadThread->wait(1000)) { // Wait briefly (1 second) for it to finish.
                 std::cerr << "Warning: Previous download thread did not finish gracefully during cleanup." << std::endl;
                 // Avoid terminating here if possible; let deleteLater handle it eventually.
            }
            // The finished signal connected later should trigger deleteLater for the old objects.
        } else {
        }
        // Clear the pointers immediately after initiating cleanup to avoid using stale objects.
        // Note: The actual deletion happens later via deleteLater.
        downloader = nullptr;
        downloadThread = nullptr;
    }
    // --- End cleanup ---

    // Create a lambda function to capture the 'this' pointer and update the progress bar.
    // This lambda will be passed to the Downloader object.
    auto updateProgress = [this](int percent) {
        // Use QMetaObject::invokeMethod to safely call the UI update code from the main GUI thread.
        // This is crucial because the lambda will be called from the download thread.
        QMetaObject::invokeMethod(this, [this, percent]() {
            // Check if the UI elements still exist (window might be closing).
            if (ui && ui->progressBar) {
                ui->progressBar->setValue(percent); // Update the progress bar value.
            }
            // Avoid explicit QCoreApplication::processEvents() here; rely on the main event loop and the timer.
        }, Qt::QueuedConnection); // QueuedConnection ensures the lambda runs in the receiver's (this window's) thread event loop.
    };

    // Create a new QThread object, setting this window as the parent for memory management.
    downloadThread = new QThread(this);
    // Create a new Downloader object, passing the URL, output path, and the progress update lambda.
    downloader = new Downloader(url.toStdString(), output.toStdString(), updateProgress);
    // Move the Downloader object to the newly created thread. All its slots will now execute in that thread.
    downloader->moveToThread(downloadThread);

    // --- Connections for the new thread and downloader ---
    // When the thread starts, call the Downloader's startDownload method.
    // --- Connect signals and slots ---
    // Existing connections
    connect(downloadThread, &QThread::started, downloader, &Downloader::startDownload);
    connect(downloader, &Downloader::downloadFinished, this, &DownloadWindow::onDownloadComplete);
    connect(downloader, &Downloader::downloadPaused, this, &DownloadWindow::onDownloadPaused);
    connect(downloader, &Downloader::downloadResumed, this, &DownloadWindow::onDownloadResumed);
    connect(downloader, &Downloader::totalSizeKnown, this, &DownloadWindow::onTotalSizeKnown);
    
    // Add this new connection
    connect(downloader, &Downloader::downloadSpeedUpdated, this, &DownloadWindow::onDownloadSpeedUpdated);
    
    // When the thread finishes (after quit() is called and the event loop stops), schedule the Downloader object for deletion.
    connect(downloadThread, &QThread::finished, downloader, &QObject::deleteLater);

    // When the thread finishes, schedule the QThread object itself for deletion.
    connect(downloadThread, &QThread::finished, downloadThread, &QObject::deleteLater);

    // Connect signals emitted by the Downloader (from the worker thread) to slots in this window (GUI thread).
    // Use QueuedConnection to ensure the slots are executed safely in the GUI thread's event loop.
    // When download finishes (successfully or not), call onDownloadComplete.
    connect(downloader, &Downloader::downloadFinished, this, &DownloadWindow::onDownloadComplete, Qt::QueuedConnection);
    // When download is paused, call onDownloadPaused.
    connect(downloader, &Downloader::downloadPaused, this, &DownloadWindow::onDownloadPaused, Qt::QueuedConnection);
    // When download is resumed, call onDownloadResumed.
    connect(downloader, &Downloader::downloadResumed, this, &DownloadWindow::onDownloadResumed, Qt::QueuedConnection);

    // *** New Connection ***
    connect(downloader, &Downloader::totalSizeKnown, this, &DownloadWindow::onTotalSizeKnown);


    // --- Start Download ---
    isDownloading = true; // Set the flag indicating a download is active.
    updateButtonStates(); // Update the button states (disable download, enable pause).
    downloadThread->start(); // Start the event loop of the download thread, which triggers the download via the 'started' signal.
}

// Slot called when the Pause/Resume button is clicked.
void DownloadWindow::onPauseResumeClicked() {
    std::cout << "Pause/Resume button clicked" << std::endl; // Debug output.
    // Do nothing if the downloader object doesn't exist.
    if (!downloader) return;

    // Optional: Could temporarily disable the button here, but updateButtonStates/updateUI should handle it.
    // ui->pauseResumeButton->setEnabled(false);

    if (downloader->isPaused()) { // If the download is currently paused...
        std::cout << "Calling resumeDownload via invokeMethod" << std::endl; // Debug output.
        // Call the resumeDownload method on the downloader object.
        // Use invokeMethod with QueuedConnection because resumeDownload might interact with network operations
        // or start the download loop again within the downloader's thread.
        QMetaObject::invokeMethod(downloader, "resumeDownload", Qt::QueuedConnection);

        // Optimistic UI update (commented out): Let updateUI or onDownloadResumed handle the final state.
        // ui->pauseResumeButton->setText("Pause");
        // ui->pauseResumeButton->setEnabled(true);
    } else { // If the download is currently running...
        std::cout << "Calling requestPause directly" << std::endl; // Debug output.
        // Call the requestPause method on the downloader object.
        // This method likely sets an atomic flag quickly, so it can be called directly
        // (though calling via invokeMethod would also be safe).
        downloader->requestPause();

        // Optimistic UI update (commented out): Let updateUI or onDownloadPaused handle the final state.
        // ui->pauseResumeButton->setText("Resume");
        // ui->pauseResumeButton->setEnabled(true);
    }
    // Removed immediate call to updateButtonStates; rely on signals (onDownloadPaused/Resumed) or the timer (updateUI)
    // for more robust state updates.
    // updateButtonStates();
}

// Slot called when the Downloader emits the downloadFinished signal.
void DownloadWindow::onDownloadComplete(bool success) {
    // Add a guard to prevent duplicate processing
    static bool processingCompletion = false;
    
    if (processingCompletion) {
        return; // Exit if we're already processing a completion
    }
    
    processingCompletion = true;
    
    // Check if this is a pause rather than a real completion/failure
    if (downloader && downloader->isPaused()) {
        std::cout << "onDownloadComplete: Ignoring 'false' success because download is paused." << std::endl;
        processingCompletion = false;
        return;
    }

    // If it's a real completion or genuine failure...
    isDownloading = false;
    updateButtonStates();

    // Reset size label only on real completion/failure, not pause
    if (!downloader || !downloader->isPaused()) {
         ui->sizeLabel->setText("Size: N/A");
         ui->speedLabel->setText("Speed: 0 B/s");
    }

    if (success) {
        QMessageBox::information(this, "Download Complete",
                                 "The file has been downloaded successfully.");
    } else if (!downloader || !downloader->isPaused()) { // Only show failure if not paused
        QMessageBox::critical(this, "Download Failed",
                              "There was an error downloading the file.");
    }
    
    processingCompletion = false;
}

// Slot called when the Downloader emits the downloadPaused signal.
void DownloadWindow::onDownloadPaused() {
    // Add a guard to prevent duplicate processing
    static bool processingPause = false;
    
    if (processingPause) {
        return; // Exit if we're already processing a pause
    }
    
    processingPause = true;
    
    // Use invokeMethod to ensure UI updates run in the main GUI thread.
    QMetaObject::invokeMethod(this, [this]() {
        std::cout << "Download paused, updating UI" << std::endl; // Debug output.
        // Optional: Show a message box indicating pause (commented out).
        // QMessageBox::information(this, "Download Paused",
        //                       "The download has been paused. Click Resume to continue.");

        // Update the pause/resume button text and state.
        ui->pauseResumeButton->setText("Resume");
        ui->pauseResumeButton->setEnabled(true);

        // Process events to ensure the UI updates immediately.
        QCoreApplication::processEvents();
    }, Qt::QueuedConnection); // Ensure execution in the GUI thread.
    
    processingPause = false;
}

// Slot called when the Downloader emits the downloadResumed signal.
void DownloadWindow::onDownloadResumed() {
    // Add a guard to prevent duplicate processing
    static bool processingResume = false;
    
    if (processingResume) {
        return; // Exit if we're already processing a resume
    }
    
    processingResume = true;
    
    // Use invokeMethod to ensure UI updates run in the main GUI thread.
    QMetaObject::invokeMethod(this, [this]() {
        std::cout << "Download resumed, updating UI" << std::endl;
        // Update the pause/resume button to show "Pause" again
        ui->pauseResumeButton->setText("Pause");
        ui->pauseResumeButton->setEnabled(true);
        isDownloading = true;
        updateButtonStates();
    }, Qt::QueuedConnection);
    
    processingResume = false;
}

// New Slot Implementation
void DownloadWindow::onTotalSizeKnown(qint64 size) {
    // Use invokeMethod to ensure UI updates run in the main GUI thread.
    QMetaObject::invokeMethod(this, [this, size]() {
        if (size >= 0) {
            // Use QLocale to format the size nicely (e.g., KB, MB, GB)
            QString formattedSize = QLocale().formattedDataSize(size);
            ui->sizeLabel->setText(QString("Size: %1").arg(formattedSize));
        } else {
            // Handle case where size couldn't be determined
            ui->sizeLabel->setText("Size: Unknown");
        }
    }, Qt::QueuedConnection);
}

void DownloadWindow::onDownloadSpeedUpdated(qint64 bytesPerSecond) {
    QMetaObject::invokeMethod(this, [this, bytesPerSecond]() {
        QString speedStr;
        if (bytesPerSecond < 1024)
            speedStr = QString("%1 B/s").arg(bytesPerSecond);
        else if (bytesPerSecond < 1024 * 1024)
            speedStr = QString::number(bytesPerSecond / 1024.0, 'f', 2) + " KB/s";
        else
            speedStr = QString::number(bytesPerSecond / 1024.0 / 1024.0, 'f', 2) + " MB/s";
        ui->speedLabel->setText("Speed: " + speedStr);
    }, Qt::QueuedConnection);
}